import logging
from selenium.webdriver.edge.service import Service
from selenium.webdriver.edge.webdriver import WebDriver as EdgeDriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from bs4 import BeautifulSoup
import pandas as pd
from datetime import datetime
import os
from PyQt5.QtWidgets import QApplication, QMainWindow, QLineEdit, QPushButton, QVBoxLayout, QWidget, QLabel
import sys
from PyQt5.QtWidgets import QSizePolicy
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from mplfinance.original_flavor import candlestick_ohlc
import matplotlib.dates as mdates
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
import plotly.graph_objects as go
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtCore import QUrl
import tempfile
import plotly.express as px
import plotly.graph_objects as go
import time
from selenium.common.exceptions import UnexpectedAlertPresentException
from PyQt5.QtWidgets import QSpinBox, QLabel
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QCheckBox
from datetime import datetime
# Configure logging
logging.basicConfig(filename='log.txt', level=logging.ERROR)

# Get the current directory
current_directory = os.path.dirname(os.path.abspath(__file__))

# Path to Edge driver
edge_driver_path = os.path.join(current_directory, 'msedgedriver.exe')

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()

        # Main layout
        main_layout = QVBoxLayout()

        # Top layout for ticker input and number of rows selection
        top_layout = QHBoxLayout()

        # Text box for ticker input
        self.ticker_input = QLineEdit()
        self.ticker_input.setPlaceholderText("Enter ticker")
        top_layout.addWidget(self.ticker_input)

        # Number of rows selection
        self.rows_label = QLabel("Number of rows:")
        top_layout.addWidget(self.rows_label)

        self.row_spin_box = QSpinBox()
        self.row_spin_box.setMinimum(1)   # Minimum number of rows
        self.row_spin_box.setMaximum(1000)  # Maximum number of rows, adjust as needed
        self.row_spin_box.setValue(300)  # Default number of rows
        top_layout.addWidget(self.row_spin_box)

        main_layout.addLayout(top_layout)  # Add top layout to main layout

        # Buttons layout
        buttons_layout = QHBoxLayout()

        # Button to start fetching data
        start_button = QPushButton("Start")
        start_button.clicked.connect(self.start_fetching_data)
        buttons_layout.addWidget(start_button)

        # Button to save data
        save_button = QPushButton("Save")
        save_button.clicked.connect(self.save_data_to_excel)
        buttons_layout.addWidget(save_button)

        main_layout.addLayout(buttons_layout)  # Add buttons layout to main layout

        # Plotly Candlestick Chart
        self.web_view = QWebEngineView()
        main_layout.addWidget(self.web_view, 1)  # This will make the web view stretch to fill the available space

        # Status label with fixed height
        self.status_label = QLabel("Status: Ready")
        self.status_label.setFixedHeight(25)  # Adjust the height as needed
        main_layout.addWidget(self.status_label)

        # Add Customize Appearance button
        customize_button = QPushButton("Customize Appearance")
        customize_button.clicked.connect(self.update_chart_appearance)
        buttons_layout.addWidget(customize_button)
        # Checkbox for SMA display
        self.sma_checkbox = QCheckBox("Show SMA")
        top_layout.addWidget(self.sma_checkbox)
        # Connect the checkbox state change signal to update the chart
        self.sma_checkbox.stateChanged.connect(self.plot_candlestick_chart)
        self.sma_period_label = QLabel("SMA Period:")
        top_layout.addWidget(self.sma_period_label)

        self.sma_period_spinbox = QSpinBox()
        self.sma_period_spinbox.setMinimum(1)   # Minimum period
        self.sma_period_spinbox.setMaximum(100)  # Maximum period, adjust as needed
        self.sma_period_spinbox.setValue(10)  # Default period of 10
        top_layout.addWidget(self.sma_period_spinbox)
        self.sma_period_spinbox.valueChanged.connect(self.recalculate_and_plot)
        # Set layout
        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)

        # Sample data for testing (replace with your actual data)
        self.df = pd.DataFrame({
            'Date': ['2021-01-01', '2021-01-02'],
            'Open': [100, 105],
            'High': [110, 115],
            'Low': [90, 95],
            'Close': [105, 100]
        })

    def start_fetching_data(self):
            ticker = self.ticker_input.text().strip()
            if ticker:
                print(f"Processing ticker: {ticker}...")
                self.df = self.process_ticker(ticker)
                self.plot_candlestick_chart()
    def calculate_sma(self, data_frame):
        sma_period = self.sma_period_spinbox.value()  # Get the period from the spinbox

        # Ensure the data_frame is sorted in ascending order by date
        data_frame = data_frame.sort_values(by='Date', ascending=True)

        # Calculate the SMA using the rolling window method
        data_frame['SMA'] = data_frame['Close'].rolling(window=sma_period).mean()
        data_frame['SMA50'] = data_frame['Close'].rolling(window=50).mean()
        data_frame['SMA200'] = data_frame['Close'].rolling(window=200).mean()
        return data_frame

    def recalculate_and_plot(self):
        if self.df is not None and not self.df.empty:
            self.df = self.calculate_sma(self.df.copy())  # Recalculate SMA with the new period, using a copy to avoid side effects
            self.plot_candlestick_chart()  # Plot the updated chart

    def process_ticker(self, ticker):
        try:
            URL = f'http://www.isx-iq.net/isxportal/portal/companyprofilecontainer.html?currLanguage=en&companyCode={ticker}&activeTab=0'

            # Initialize Edge driver
            driver_service = Service(edge_driver_path)
            driver = EdgeDriver(service=driver_service)
            driver.get(URL)
            
            # Adjust the value of the input field
            driver.execute_script('document.querySelector("#fromDate").value = "06/10/2010";')

            # Wait for the change to take effect (you can adjust the waiting time as per your needs)
            WebDriverWait(driver, 5).until(lambda driver: driver.execute_script('return document.querySelector("#fromDate").value;') == "06/10/2010")

            # Find the button using the provided XPath and click it
            driver.execute_script('document.querySelector("#command > div.filterbox > div.button-all").click();')
            # Wait for a couple of seconds after pressing the button
            time.sleep(2)
            # Wait for table to load
            print("Waiting for table to load...")
            WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "#dispTable")))

            # Initialize DataFrame
            df = pd.DataFrame(columns=[
                "Date", "Open", "High", "Low", "Close", "Change", "Change%", "T.Shares", "Volume", "No. Trades"
            ])
            #Calculating SMA
            sma_period = 10  # Example period for SMA
            page_num = 1
            desired_rows = self.row_spin_box.value()  # Get the value from the QSpinBox
            while len(df) < desired_rows:
                print(f"Scraping page {page_num}...")
                table_html = driver.execute_script('return document.querySelector("#dispTable").outerHTML;')
                soup = BeautifulSoup(table_html, 'html.parser')
                table = soup.find('table')

                # Extracting data and appending to DataFrame
                for row in table.find_all('tr')[1:]:
                    cols = row.find_all('td')
                    date = datetime.strptime(cols[9].text.strip(), '%d/%m/%Y').date()
                    open_price = float(cols[8].text.strip().replace(',', ''))
                    high = float(cols[7].text.strip().replace(',', ''))
                    low = float(cols[6].text.strip().replace(',', ''))
                    close = float(cols[5].text.strip().replace(',', ''))
                    change = float(cols[4].text.strip().replace(',', ''))
                    change_percent = float(cols[3].text.strip().replace('%', '').replace(',', ''))
                    t_shares = int(cols[2].text.strip().replace(',', ''))
                    volume = int(cols[1].text.strip().replace(',', ''))
                    no_trades = int(cols[0].text.strip().replace(',', ''))
                    row_data = [date, open_price, high, low, close, change, change_percent, t_shares, volume, no_trades]
                    df.loc[len(df)] = row_data
                # Call calculate_sma for each data point
                print("Before calculate_sma:", df.shape)
                # df = self.calculate_sma(df, sma_period)
                print("After calculate_sma:", df.shape)
                # Break loop if 300 or more rows collected
                if len(df) >= desired_rows:
                    break

                # Navigate to the next pageit
                next_page_btn_selector = "#ajxDspId > div > span.pagelinks > a:nth-child(11)"
                next_page_btn = driver.find_element(By.CSS_SELECTOR, next_page_btn_selector)
                if next_page_btn:
                    next_page_btn.click()
                    WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "#dispTable")))

                page_num += 1
            #Calculating SMA
            df = self.calculate_sma(df)
            df = df.sort_values(by='Date', ascending=True)
            return df  # Return the DataFrame
        except UnexpectedAlertPresentException:
            # Handle the alert and accept it
            alert = driver.switch_to.alert
            alert.accept()

            # After accepting the alert, return to the same location in the code
            return self.process_ticker(ticker)
        except Exception as e:
            # Log the error
            logging.error(f"An error occurred while processing ticker {ticker}: {str(e)}")
            # Closing the driver
            if 'driver' in locals():
                driver.quit()
            print(f"An error occurred while processing {ticker}: {str(e)}")
            return None
    def plot_candlestick_chart(self):
        # Check if the DataFrame is not empty
        if self.df is None or self.df.empty:
            self.status_label.setText("No data available to plot.")
            return
        if self.df is not None and not self.df.empty:
            # Compute min and max values from the 'Low' and 'High' columns
            data_min = self.df['Low'].min()
            data_max = self.df['High'].max()

            # Adjust for the 10% zoom
            yaxis_range = [data_min - 0.1 * (data_max - data_min), data_max + 0.1 * (data_max - data_min)]

            # Create the figure with Candlestick data
            fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                                open=self.df['Open'],
                                                high=self.df['High'],
                                                low=self.df['Low'],
                                                close=self.df['Close'])])

            # If the checkbox is checked, add the SMA line to the figure
            if self.sma_checkbox.isChecked():
                fig.add_trace(go.Scatter(x=self.df['Date'], y=self.df['SMA'], mode='lines', name='SMA'))
                fig.add_trace(go.Scatter(x=self.df['Date'], y=self.df['SMA50'], mode='lines', name='SMA50', line=dict(color='green')))
                fig.add_trace(go.Scatter(x=self.df['Date'], y=self.df['SMA200'], mode='lines', name='SMA200', line=dict(color='orange')))
            # Set the y-axis range
            fig.update_layout(yaxis_range=yaxis_range)

            raw_html = fig.to_html(include_plotlyjs='cdn')
            self.web_view.setHtml(raw_html)
    
    def save_data_to_excel(self):
            if self.df is not None:
                # Get the current datetime
                now = datetime.now()
                # Format the datetime and combine with the ticker name to form the filename
                ticker = self.ticker_input.text().strip()
                filename = f"{now.strftime('%Y-%m-%d %H-%M-%S')}_{ticker}.xlsx"
                with pd.ExcelWriter(filename, engine='openpyxl') as writer:
                    self.df.to_excel(writer, sheet_name='Sheet1', index=False)
                    self.df[['Date', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet2', index=False)
                    self.df[['Date', 'Volume', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet3', index=False)
                    self.df[['Volume', 'Open', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet4', index=False)
                    sma_df = self.df[['Date', 'High', 'Low', 'Close','SMA','SMA50', 'SMA200']]
                    sma_df.to_excel(writer, sheet_name='SMA', index=False)  # Corrected 'sdf' to 'sma_df'
                self.status_label.setText("Data saved successfully.")
            else:
                self.status_label.setText("No data available to save.")
    def update_chart_appearance(self):
        fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                            open=self.df['Open'],
                                            high=self.df['High'],
                                            low=self.df['Low'],
                                            close=self.df['Close'])])

        # Apply custom appearance settings
        fig.update_layout(
            title="Custom Candlestick Chart",
            xaxis_title="Date",
            yaxis_title="Price",
            yaxis=dict(autorange=True, fixedrange=False),  # Allow y-axis zooming
            colorway=["green", "red"],  # Change color scheme
        )

        raw_html = fig.to_html(include_plotlyjs='cdn')
        self.web_view.setHtml(raw_html)
    def enable_chart_interactions(self):
        fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                            open=self.df['Open'],
                                            high=self.df['High'],
                                            low=self.df['Low'],
                                            close=self.df['Close'])])

        # Enable chart interactions
        fig.update_layout(
            xaxis=dict(rangeslider=dict(visible=False)),  # Disable range slider
            xaxis_rangeslider=dict(visible=True),  # Enable separate x-axis slider
            yaxis=dict(autorange=True, fixedrange=False),  # Allow y-axis zooming
            dragmode="zoom",  # Enable zooming
            showlegend=False  # Disable legend for simplicity
        )

        raw_html = fig.to_html(include_plotlyjs='cdn')
        self.web_view.setHtml(raw_html)
    def enable_data_point_highlight(self):
        fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                            open=self.df['Open'],
                                            high=self.df['High'],
                                            low=self.df['Low'],
                                            close=self.df['Close'])])

        # Enable data point highlight
        fig.update_layout(
            xaxis=dict(rangeslider=dict(visible=False)),
            xaxis_rangeslider=dict(visible=True),
            yaxis=dict(autorange=True, fixedrange=False),
            dragmode="zoom",
            showlegend=False,
            hovermode="x unified",  # Highlight data points on hover across all subplots
            hovertemplate="%{x}<br>Open: %{open}<br>Close: %{close}<extra></extra>",  # Custom hover template
        )

        raw_html = fig.to_html(include_plotlyjs='cdn')
        self.web_view.setHtml(raw_html)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
