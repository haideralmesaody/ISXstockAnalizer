# Standard Libraries
import logging
import os
import sys
import time
from datetime import datetime

# Third-party Libraries
from PyQt5.QtCore import QUrl
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtWidgets import (QApplication, QCheckBox, QHBoxLayout, QLabel,
                             QLineEdit, QMainWindow, QPushButton, QSizePolicy,
                             QSpinBox, QVBoxLayout, QWidget)
from bs4 import BeautifulSoup
import matplotlib.dates as mdates
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT
from matplotlib.figure import Figure
from mplfinance.original_flavor import candlestick_ohlc
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from selenium.common.exceptions import UnexpectedAlertPresentException
from selenium.webdriver.common.by import By
from selenium.webdriver.edge.service import Service
from selenium.webdriver.edge.webdriver import WebDriver as EdgeDriver
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
# Configure logging
logging.basicConfig(filename='app.log', level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the current directory
current_directory = os.path.dirname(os.path.abspath(__file__))

# Path to Edge driver
edge_driver_path = os.path.join(current_directory, 'msedgedriver.exe')

class MainWindow(QMainWindow):
        # ------- Initialization and General Setup Methods --------
        def __init__(self):
            super(MainWindow, self).__init__()
            # Initialize the user interface
            self.setup_ui()

            # Connect button signals to their respective slots
            self.connect_buttons()

            # Initialize DataFrame for data storage
            self.df = None

        def setup_ui(self):
            """Initialize the user interface layout."""
            main_layout = QVBoxLayout()

            # Set up the top layout containing input widgets
            self.setup_top_layout(main_layout)

            # Set up the layout for buttons
            self.setup_buttons_layout(main_layout)

            # Set up the web view for displaying charts
            self.setup_web_view(main_layout)

            # Set up the status label
            self.setup_status_label(main_layout)

            # Set up the "Customize Appearance" button
            self.setup_customize_button(main_layout)

            # Create a central widget with the main layout
            central_widget = QWidget()
            central_widget.setLayout(main_layout)
            self.setCentralWidget(central_widget)

        def connect_buttons(self):
            """Connect signals of buttons to their corresponding slots."""
            self.sma_checkbox.stateChanged.connect(self.plot_candlestick_chart)
            self.sma_period_spinbox.valueChanged.connect(self.recalculate_and_plot)
            self.rsi_checkbox.stateChanged.connect(self.plot_candlestick_chart)
        # ------- UI Component Setup Methods --------
    
        def setup_top_layout(self, main_layout):
            """Set up the top layout containing input widgets."""
            top_layout = QHBoxLayout()
            self.ticker_input = QLineEdit()
            self.ticker_input.setPlaceholderText("Enter ticker")
            top_layout.addWidget(self.ticker_input)

            self.rows_label = QLabel("Number of rows:")
            top_layout.addWidget(self.rows_label)

            self.row_spin_box = QSpinBox()
            self.row_spin_box.setMinimum(1)
            self.row_spin_box.setMaximum(1000)
            self.row_spin_box.setValue(300)
            top_layout.addWidget(self.row_spin_box)

            self.sma_checkbox = QCheckBox("Show SMA")
            top_layout.addWidget(self.sma_checkbox)

            self.sma_period_label = QLabel("SMA Period:")
            top_layout.addWidget(self.sma_period_label)
            # RSI Checkbox
            self.rsi_checkbox = QCheckBox("Show RSI14")
            top_layout.addWidget(self.rsi_checkbox)
            self.sma_period_spinbox = QSpinBox()
            self.sma_period_spinbox.setMinimum(1)
            self.sma_period_spinbox.setMaximum(100)
            self.sma_period_spinbox.setValue(10)
            top_layout.addWidget(self.sma_period_spinbox)

            main_layout.addLayout(top_layout)

        def setup_buttons_layout(self, main_layout):
            """Set up the layout for buttons."""
            buttons_layout = QHBoxLayout()

            start_button = QPushButton("Start")
            start_button.clicked.connect(self.start_fetching_data)
            buttons_layout.addWidget(start_button)

            save_button = QPushButton("Save")
            save_button.clicked.connect(self.save_data_to_excel)
            buttons_layout.addWidget(save_button)

            main_layout.addLayout(buttons_layout)

        def setup_web_view(self, main_layout):
            """Set up the web view for displaying charts."""
            self.web_view = QWebEngineView()
            main_layout.addWidget(self.web_view, 1)

        def setup_status_label(self, main_layout):
            """Set up the status label."""
            self.status_label = QLabel("Status: Ready")
            self.status_label.setFixedHeight(25)
            main_layout.addWidget(self.status_label)

        def setup_customize_button(self, main_layout):
            """Set up the "Customize Appearance" button."""
            customize_button = QPushButton("Customize Appearance")
            customize_button.clicked.connect(self.update_chart_appearance)
            main_layout.addWidget(customize_button)
        # ------- Data Fetching and Processing Methods --------


        def start_fetching_data(self):
            """Fetch and process data based on user input."""
            try:
                ticker = self.ticker_input.text().strip()
                if ticker:
                    logging.info(f"Processing ticker: {ticker}...")
                    self.df = self.process_ticker(ticker)
                    self.plot_candlestick_chart()
                    print(self.df.columns)
            except Exception as e:
                logging.error(f"An error occurred in start_fetching_data: {str(e)}")
        def process_ticker(self, ticker):
            """Fetch and process data from the website."""
            try:
                URL = f'http://www.isx-iq.net/isxportal/portal/companyprofilecontainer.html?currLanguage=en&companyCode={ticker}&activeTab=0'

                # Initialize Edge driver
                driver_service = Service(edge_driver_path)
                driver = EdgeDriver(service=driver_service)
                driver.get(URL)
                
                # Adjust the value of the input field
                driver.execute_script('document.querySelector("#fromDate").value = "06/10/2010";')

                # Wait for the change to take effect (you can adjust the waiting time as per your needs)
                WebDriverWait(driver, 5).until(lambda driver: driver.execute_script('return document.querySelector("#fromDate").value;') == "06/10/2010")

                # Find the button using the provided XPath and click it
                driver.execute_script('document.querySelector("#command > div.filterbox > div.button-all").click();')
                # Wait for a couple of seconds after pressing the button
                time.sleep(2)
                # Wait for table to load
                print("Waiting for table to load...")
                WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "#dispTable")))

                # Initialize DataFrame
                df = pd.DataFrame(columns=[
                    "Date", "Open", "High", "Low", "Close", "Change", "Change%", "T.Shares", "Volume", "No. Trades"
                ])
                #Calculating SMA
                sma_period = 10  # Example period for SMA
                page_num = 1
                desired_rows = self.row_spin_box.value()  # Get the value from the QSpinBox
                while len(df) < desired_rows:
                    print(f"Scraping page {page_num}...")
                    table_html = driver.execute_script('return document.querySelector("#dispTable").outerHTML;')
                    soup = BeautifulSoup(table_html, 'html.parser')
                    table = soup.find('table')

                    # Extracting data and appending to DataFrame
                    for row in table.find_all('tr')[1:]:
                        cols = row.find_all('td')
                        date = datetime.strptime(cols[9].text.strip(), '%d/%m/%Y').date()
                        open_price = float(cols[8].text.strip().replace(',', ''))
                        high = float(cols[7].text.strip().replace(',', ''))
                        low = float(cols[6].text.strip().replace(',', ''))
                        close = float(cols[5].text.strip().replace(',', ''))
                        change = float(cols[4].text.strip().replace(',', ''))
                        change_percent = float(cols[3].text.strip().replace('%', '').replace(',', ''))
                        t_shares = int(cols[2].text.strip().replace(',', ''))
                        volume = int(cols[1].text.strip().replace(',', ''))
                        no_trades = int(cols[0].text.strip().replace(',', ''))
                        row_data = [date, open_price, high, low, close, change, change_percent, t_shares, volume, no_trades]
                        df.loc[len(df)] = row_data
                    # Call calculate_sma for each data point
                    print("Before calculate_sma:", df.shape)
                    # df = self.calculate_sma(df, sma_period)
                    print("After calculate_sma:", df.shape)
                    # Break loop if 300 or more rows collected
                    if len(df) >= desired_rows:
                        break

                    # Navigate to the next pageit
                    next_page_btn_selector = "#ajxDspId > div > span.pagelinks > a:nth-child(11)"
                    next_page_btn = driver.find_element(By.CSS_SELECTOR, next_page_btn_selector)
                    if next_page_btn:
                        next_page_btn.click()
                        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "#dispTable")))

                    page_num += 1
                #Calculating SMA
                df = self.calculate_sma(df)
                df = df.sort_values(by='Date', ascending=True)
                # Calculate RSI14 and add it to the DataFrame
                
                df['RSI14'] = self.calculate_rsi(df)
                return df  # Return the DataFrame
            except UnexpectedAlertPresentException:
                # Handle the alert and accept it
                alert = driver.switch_to.alert
                alert.accept()

                # After accepting the alert, return to the same location in the code
                return self.process_ticker(ticker)
            except Exception as e:
                # Log the error
                logging.error(f"An error occurred while processing ticker {ticker}: {str(e)}")
                # Closing the driver
                if 'driver' in locals():
                    driver.quit()
                print(f"An error occurred while processing {ticker}: {str(e)}")
                return None
            
        def calculate_sma(self, data_frame):
            """Calculate simple moving averages."""
            try:
                sma_period = self.sma_period_spinbox.value()  # Get the period from the spinbox

                # Ensure the data_frame is sorted in ascending order by date
                data_frame = data_frame.sort_values(by='Date', ascending=True)

                # Calculate the SMA using the rolling window method
                data_frame['SMA'] = data_frame['Close'].rolling(window=sma_period).mean()
                data_frame['SMA50'] = data_frame['Close'].rolling(window=50).mean()
                data_frame['SMA200'] = data_frame['Close'].rolling(window=200).mean()
                return data_frame
            except Exception as e:
                logging.error(f"An error occurred in calculate_sma: {str(e)}")

        def calculate_rsi(self, data_frame, period=14):
            try:
                delta = data_frame['Close'].diff()
                
                # Separate the gains and losses into their own series
                gain = (delta.where(delta > 0, 0)).fillna(0)
                loss = (-delta.where(delta < 0, 0)).fillna(0)
                
                # Calculate the average gain and loss over the desired period
                avg_gain = gain.rolling(window=period, min_periods=1).mean()
                avg_loss = loss.rolling(window=period, min_periods=1).mean()
                
                # Calculate RS
                rs = avg_gain / avg_loss
                
                # Calculate RSI
                rsi = 100 - (100 / (1 + rs))
                
                return rsi
            except Exception as e:
                logging.error(f"An error occurred in calculate_rsi: {str(e)}")
                return None

        def recalculate_and_plot(self):
            try:
                if self.df is not None and not self.df.empty:
                    self.df = self.calculate_sma(self.df.copy())  # Recalculate SMA with the new period, using a copy to avoid side effects
                    self.plot_candlestick_chart()  # Plot the updated chart
            except Exception as e:
                logging.error(f"An error occurred in recalculate_and_plot: {str(e)}")

         # ------- Chart Plotting and Visualization Methods --------
        def plot_candlestick_chart(self):
            """Plot the candlestick chart."""
            try:
                # Check if the DataFrame is not empty
                if self.df is None or self.df.empty:
                    self.status_label.setText("No data available to plot.")
                    return
                if self.df is not None and not self.df.empty:
                    # Compute min and max values from the 'Low' and 'High' columns
                    data_min = self.df['Low'].min()
                    data_max = self.df['High'].max()

                    # Adjust for the 10% zoom
                    yaxis_range = [data_min - 0.1 * (data_max - data_min), data_max + 0.1 * (data_max - data_min)]

                    # Create the figure with Candlestick data
                    fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                                        open=self.df['Open'],
                                                        high=self.df['High'],
                                                        low=self.df['Low'],
                                                        close=self.df['Close'])])

                    # If the checkbox is checked, add the SMA line to the figure
                    if self.sma_checkbox.isChecked():
                        fig.add_trace(go.Scatter(x=self.df['Date'], y=self.df['SMA'], mode='lines', name='SMA'))
                        fig.add_trace(go.Scatter(x=self.df['Date'], y=self.df['SMA50'], mode='lines', name='SMA50', line=dict(color='green')))
                        fig.add_trace(go.Scatter(x=self.df['Date'], y=self.df['SMA200'], mode='lines', name='SMA200', line=dict(color='orange')))
                    # Set the y-axis range
                    if self.rsi_checkbox.isChecked():
                        fig.add_trace(go.Scatter(x=self.df['Date'], y=self.df['RSI14'], mode='lines', name='RSI14', yaxis='y2',line=dict(color='navy')))
                        # Add guidelines at 70 and 30 for RSI
                        fig.add_shape(type="line",
                                    x0=self.df['Date'].iloc[0], x1=self.df['Date'].iloc[-1],
                                    y0=70, y1=70,
                                    yref='y2',
                                    line=dict(color="blue",))
                        fig.add_shape(type="line",
                                    x0=self.df['Date'].iloc[0], x1=self.df['Date'].iloc[-1],
                                    y0=30, y1=30,
                                    yref='y2',
                                    line=dict(color="blue",))
                    fig.update_layout(yaxis_range=yaxis_range)
                    fig.update_layout(
                        yaxis2=dict(title="RSI", overlaying='y', side='right', range=[0, 100])
                    )
                    raw_html = fig.to_html(include_plotlyjs='cdn')
                    self.web_view.setHtml(raw_html)
            except Exception as e:
                logging.error(f"An error occurred in plot_candlestick_chart: {str(e)}")

        def update_chart_appearance(self):
            """Update the appearance of the chart."""
            try:
                fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                                    open=self.df['Open'],
                                                    high=self.df['High'],
                                                    low=self.df['Low'],
                                                    close=self.df['Close'])])

                # Apply custom appearance settings
                fig.update_layout(
                    title="Custom Candlestick Chart",
                    xaxis_title="Date",
                    yaxis_title="Price",
                    yaxis=dict(autorange=True, fixedrange=False),  # Allow y-axis zooming
                    colorway=["green", "red"],  # Change color scheme
                )

                raw_html = fig.to_html(include_plotlyjs='cdn')
                self.web_view.setHtml(raw_html)
            except Exception as e:
                logging.error(f"An error occurred in update_chart_appearance: {str(e)}")

        def enable_chart_interactions(self):
            fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                                open=self.df['Open'],
                                                high=self.df['High'],
                                                low=self.df['Low'],
                                                close=self.df['Close'])])

            # Enable chart interactions
            fig.update_layout(
                xaxis=dict(rangeslider=dict(visible=False)),  # Disable range slider
                xaxis_rangeslider=dict(visible=True),  # Enable separate x-axis slider
                yaxis=dict(autorange=True, fixedrange=False),  # Allow y-axis zooming
                dragmode="zoom",  # Enable zooming
                showlegend=False  # Disable legend for simplicity
            )

            raw_html = fig.to_html(include_plotlyjs='cdn')
            self.web_view.setHtml(raw_html)
        def enable_data_point_highlight(self):
            fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                                open=self.df['Open'],
                                                high=self.df['High'],
                                                low=self.df['Low'],
                                                close=self.df['Close'])])

            # Enable data point highlight
            fig.update_layout(
                xaxis=dict(rangeslider=dict(visible=False)),
                xaxis_rangeslider=dict(visible=True),
                yaxis=dict(autorange=True, fixedrange=False),
                dragmode="zoom",
                showlegend=False,
                hovermode="x unified",  # Highlight data points on hover across all subplots
                hovertemplate="%{x}<br>Open: %{open}<br>Close: %{close}<extra></extra>",  # Custom hover template
            )

            raw_html = fig.to_html(include_plotlyjs='cdn')
            self.web_view.setHtml(raw_html)

        # ------- File Operation Methods --------

        def save_data_to_excel(self):
            """Save data to Excel file."""
            print(self.df.columns)
            try:
                if self.df is not None:
                    # Get the current datetime
                    now = datetime.now()
                    # Format the datetime and combine with the ticker name to form the filename
                    ticker = self.ticker_input.text().strip()
                    filename = f"{now.strftime('%Y-%m-%d %H-%M-%S')}_{ticker}.xlsx"
                    with pd.ExcelWriter(filename, engine='openpyxl') as writer:
                        self.df.to_excel(writer, sheet_name='Sheet1', index=False)  # This already includes all columns, including RSI14
                        self.df[['Date', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet2', index=False)
                        self.df[['Date', 'Volume', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet3', index=False)
                        self.df[['Volume', 'Open', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet4', index=False)
                        sma_df = self.df[['Date', 'High', 'Low', 'Close','SMA','SMA50', 'SMA200']]
                        sma_df.to_excel(writer, sheet_name='SMA', index=False)
                    self.status_label.setText("Data saved successfully.")
                else:
                    self.status_label.setText("No data available to save.")
            except Exception as e:
                logging.error(f"An error occurred in save_data_to_excel: {str(e)}") 
   



        

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
