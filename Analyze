import logging
from selenium.webdriver.edge.service import Service
from selenium.webdriver.edge.webdriver import WebDriver as EdgeDriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from bs4 import BeautifulSoup
import pandas as pd
from datetime import datetime
import os
from PyQt5.QtWidgets import QApplication, QMainWindow, QLineEdit, QPushButton, QVBoxLayout, QWidget, QLabel
import sys
from PyQt5.QtWidgets import QSizePolicy
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from mplfinance.original_flavor import candlestick_ohlc
import matplotlib.dates as mdates
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
import plotly.graph_objects as go
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtCore import QUrl
import tempfile
import plotly.express as px
import plotly.graph_objects as go
import time
from selenium.common.exceptions import UnexpectedAlertPresentException
from PyQt5.QtWidgets import QSpinBox, QLabel
from PyQt5.QtWidgets import QHBoxLayout

# Configure logging
logging.basicConfig(filename='log.txt', level=logging.ERROR)

# Get the current directory
current_directory = os.path.dirname(os.path.abspath(__file__))

# Path to Edge driver
edge_driver_path = os.path.join(current_directory, 'msedgedriver.exe')

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()

        # Main layout
        main_layout = QVBoxLayout()

        # Top layout for ticker input and number of rows selection
        top_layout = QHBoxLayout()

        # Text box for ticker input
        self.ticker_input = QLineEdit()
        self.ticker_input.setPlaceholderText("Enter ticker")
        top_layout.addWidget(self.ticker_input)

        # Number of rows selection
        self.rows_label = QLabel("Number of rows:")
        top_layout.addWidget(self.rows_label)

        self.row_spin_box = QSpinBox()
        self.row_spin_box.setMinimum(1)   # Minimum number of rows
        self.row_spin_box.setMaximum(1000)  # Maximum number of rows, adjust as needed
        self.row_spin_box.setValue(300)  # Default number of rows
        top_layout.addWidget(self.row_spin_box)

        main_layout.addLayout(top_layout)  # Add top layout to main layout

        # Buttons layout
        buttons_layout = QHBoxLayout()

        # Button to start fetching data
        start_button = QPushButton("Start")
        start_button.clicked.connect(self.start_fetching_data)
        buttons_layout.addWidget(start_button)

        # Button to save data
        save_button = QPushButton("Save")
        save_button.clicked.connect(self.save_data_to_excel)
        buttons_layout.addWidget(save_button)

        main_layout.addLayout(buttons_layout)  # Add buttons layout to main layout

        # Plotly Candlestick Chart
        self.web_view = QWebEngineView()
        main_layout.addWidget(self.web_view, 1)  # This will make the web view stretch to fill the available space

        # Status label with fixed height
        self.status_label = QLabel("Status: Ready")
        self.status_label.setFixedHeight(25)  # Adjust the height as needed
        main_layout.addWidget(self.status_label)

        # Set layout
        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)

        # Sample data for testing (replace with your actual data)
        self.df = pd.DataFrame({
            'Date': ['2021-01-01', '2021-01-02'],
            'Open': [100, 105],
            'High': [110, 115],
            'Low': [90, 95],
            'Close': [105, 100]
        })

    def start_fetching_data(self):
            ticker = self.ticker_input.text().strip()
            if ticker:
                print(f"Processing ticker: {ticker}...")
                self.df = self.process_ticker(ticker)
                self.plot_candlestick_chart()

    def process_ticker(self, ticker):
        try:
            URL = f'http://www.isx-iq.net/isxportal/portal/companyprofilecontainer.html?currLanguage=en&companyCode={ticker}&activeTab=0'

            # Initialize Edge driver
            driver_service = Service(edge_driver_path)
            driver = EdgeDriver(service=driver_service)
            driver.get(URL)
            
            # Adjust the value of the input field
            driver.execute_script('document.querySelector("#fromDate").value = "06/10/2010";')

            # Wait for the change to take effect (you can adjust the waiting time as per your needs)
            WebDriverWait(driver, 5).until(lambda driver: driver.execute_script('return document.querySelector("#fromDate").value;') == "06/10/2010")

            # Find the button using the provided XPath and click it
            driver.execute_script('document.querySelector("#command > div.filterbox > div.button-all").click();')
            # Wait for a couple of seconds after pressing the button
            time.sleep(2)
            # Wait for table to load
            print("Waiting for table to load...")
            WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "#dispTable")))

            # Initialize DataFrame
            df = pd.DataFrame(columns=[
                "Date", "Open", "High", "Low", "Close", "Change", "Change%", "T.Shares", "Volume", "No. Trades"
            ])

            page_num = 1
            desired_rows = self.row_spin_box.value()  # Get the value from the QSpinBox
            while len(df) < desired_rows:
                print(f"Scraping page {page_num}...")
                table_html = driver.execute_script('return document.querySelector("#dispTable").outerHTML;')
                soup = BeautifulSoup(table_html, 'html.parser')
                table = soup.find('table')

                # Extracting data and appending to DataFrame
                for row in table.find_all('tr')[1:]:
                    cols = row.find_all('td')
                    date = datetime.strptime(cols[9].text.strip(), '%d/%m/%Y').date()
                    open_price = float(cols[8].text.strip().replace(',', ''))
                    high = float(cols[7].text.strip().replace(',', ''))
                    low = float(cols[6].text.strip().replace(',', ''))
                    close = float(cols[5].text.strip().replace(',', ''))
                    change = float(cols[4].text.strip().replace(',', ''))
                    change_percent = float(cols[3].text.strip().replace('%', '').replace(',', ''))
                    t_shares = int(cols[2].text.strip().replace(',', ''))
                    volume = int(cols[1].text.strip().replace(',', ''))
                    no_trades = int(cols[0].text.strip().replace(',', ''))
                    row_data = [date, open_price, high, low, close, change, change_percent, t_shares, volume, no_trades]
                    df.loc[len(df)] = row_data

                # Break loop if 300 or more rows collected
                if len(df) >= desired_rows:
                    break

                # Navigate to the next page
                next_page_btn_selector = "#ajxDspId > div > span.pagelinks > a:nth-child(11)"
                next_page_btn = driver.find_element(By.CSS_SELECTOR, next_page_btn_selector)
                if next_page_btn:
                    next_page_btn.click()
                    WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "#dispTable")))

                page_num += 1

            # Closing the driver
            driver.quit()

            return df  # Return the DataFrame
        except UnexpectedAlertPresentException:
            # Handle the alert and accept it
            alert = driver.switch_to.alert
            alert.accept()

            # After accepting the alert, return to the same location in the code
            return self.process_ticker(ticker)
        except Exception as e:
            # Log the error
            logging.error(f"An error occurred while processing ticker {ticker}: {str(e)}")
            # Closing the driver
            if 'driver' in locals():
                driver.quit()
            print(f"An error occurred while processing {ticker}: {str(e)}")
            return None
    def plot_candlestick_chart(self):
        if self.df is not None and not self.df.empty:
            # Compute min and max values from the 'Low' and 'High' columns
            data_min = self.df['Low'].min()
            data_max = self.df['High'].max()

            # Adjust for the 10% zoom
            yaxis_range = [data_min - 0.1 * (data_max - data_min), data_max + 0.1 * (data_max - data_min)]

            fig = go.Figure(data=[go.Candlestick(x=self.df['Date'],
                                                open=self.df['Open'],
                                                high=self.df['High'],
                                                low=self.df['Low'],
                                                close=self.df['Close'])])

            # Set the y-axis range
            fig.update_layout(yaxis_range=yaxis_range)

            raw_html = fig.to_html(include_plotlyjs='cdn')
            self.web_view.setHtml(raw_html)

    def save_data_to_excel(self):
            if self.df is not None:
                with pd.ExcelWriter(f'output.xlsx', engine='openpyxl') as writer:
                    self.df.to_excel(writer, sheet_name='Sheet1', index=False)
                    self.df[['Date', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet2', index=False)
                    self.df[['Date', 'Volume', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet3', index=False)
                    self.df[['Volume', 'Open', 'High', 'Low', 'Close']].to_excel(writer, sheet_name='Sheet4', index=False)
                self.status_label.setText("Data saved successfully.")
            else:
                self.status_label.setText("No data available to save.")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
